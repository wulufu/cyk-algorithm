import argparse
import re

CFG_FILE_NAME = "cfg.txt"
CNF_PATTERN = re.compile("[A-Z]->([A-Z][A-Z]|[^A-Z])")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--file",
                        default=CFG_FILE_NAME,
                        help='the file to generate rules from '
                              '(default: "%(default)s")')
    args = parser.parse_args()
    rules = generate_rules(args.file)

    if rules is None:
        print("The file does not contain a valid CFG in CNF.")
        return

    while True:
        input_string = input("Enter a string: ")
        result = perform_cyk(input_string, rules)
        print(f'The string "{input_string}" {"can" if result else "can't"} '
              'be generated by the CFG.')


# Returns a dictionary of rules corresponding to lines found in the file,
# or returns None if the file does not contain a valid CFG in CNF. To be
# valid, each line in the file must be of the form A -> BC or A -> a, where
# A, B, and C are non-terminal symbols, and a is a terminal symbol.
def generate_rules(file_name: str) -> dict[str, list[str]] | None:
    rules: dict[str, list[str]] = {}

    with open(file_name) as file:
        lines = file.readlines()

    for line in lines:
        rule = re.sub(r"\s+", "", line)

        if not re.fullmatch(CNF_PATTERN, rule):
            return None

        split_rule = rule.split("->")
        lhs = split_rule[0]
        rhs = split_rule[1]

        if lhs not in rules:
            rules[lhs] = [rhs]
        else:
            rules[lhs].append(rhs)

    return rules


# Uses the CYK algorithm to determine if the input string can be generated
# by the rules provided.
def perform_cyk(input_string: str, rules: dict[str, list[str]]) -> bool:
    if not input_string:
        return False

    length = len(input_string)
    table = [[set() for _ in range(length)] for _ in range(length)]

    # Generate bottom row using the input string
    for i in range(length):
        for variable in rules:
            if input_string[i] in rules[variable]:
                table[i][i].add(variable)

    # Generate remaining rows using dynamic programming approach
    for row in range(1, length):
        for i in range(length - row):
            j = i + row

            for k in range(row):
                result = cross_product(table[i][i + k], table[i + k + 1][j])

                # Look for any variables that produce strings in the result
                for string in result:
                    for variable in rules:
                        if string in rules[variable]:
                            table[i][j].add(variable)

    start_variable = next(iter(rules))
    top_row = table[0][length - 1]
    return start_variable in top_row


# Computes and returns the cross product of two sets of strings.
def cross_product(first_set: set[str], second_set: set[str]) -> set[str]:
    result = set()

    for string_first in first_set:
        for string_second in second_set:
            result.add(string_first + string_second)

    return result


if __name__ == "__main__":
    main()
