"""CYK Algorithm

This script creates a context-free grammar from a text file and uses it to
perform CYK on strings. The path for this file can be provided using '-c' or
'--cfg' when running the script, otherwise the user will be prompted for it.
Additionally, a file containing a list of strings to test can be provided
using '-t' or '--test'. The program will exit if any file is not found.

Each line in the CFG file must be of the form "A -> BC", "S -> epsilon", or
"A -> a", where 'A', 'B', and 'C' are variables, 'S' is the axiom, and 'a' is
a terminal. Optionally, two or more rules with the same left-hand side can be
combined into one line using the form "A -> BC | a".

A variable that appears on the right-hand side of a rule must also be
defined on the left-hand side of at least one rule. The first variable
to be defined is assumed to be the axiom of the CFG. If any rule in the file
is formatted incorrectly, the program will exit.

If a test file has been provided, the results from performing CYK on the
strings found within the file will be displayed. Each line in the file is
treated as an individual string.

Otherwise, with no test file, the user will be prompted to enter a string.
CYK will be performed on this string, and the result will be displayed.
This will repeat indefinitely until the program is terminated.

This file can also be imported as a module to gain access to the CFG class for
testing whether strings can be generated by a context-free grammar, along with
the CFGFormatError exception, raised when attempting to create a CFG from an
invalid list of rules.
"""

import argparse
import re
import sys


def main() -> None:
    """Run the script with command-line arguments."""
    args = _parse_cmdline_args()

    if args.cfg is not None:
        cfg_file = args.cfg
    else:
        cfg_file = input("Enter the path of a CFG file: ")

    cfg_rules = _get_file_lines(cfg_file)

    try:
        cfg = CFG(cfg_rules)
    except CFGFormatError:
        print(f'File "{cfg_file}" does not contain a valid CFG.')
        sys.exit(1)

    if args.test is not None:
        test_strings = _get_file_lines(args.test)

        for string in test_strings:
            _test_and_print(string, cfg)
    else:
        while True:
            _test_user_input(cfg)


class CFG:
    """Used to test if strings can be generated by a context-free grammar."""

    _EPSILON = "epsilon"
    _PATTERN = re.compile(fr"[A-Z]->([A-Z][A-Z]|[^A-Z|]|{_EPSILON})"
                          fr"(\|([A-Z][A-Z]|[^A-Z|]|{_EPSILON}))*")

    def __init__(self, rules: list[str]) -> None:
        """Convert a list of strings representing rules into a CFG.

        Each rule must be of the form "A -> BC", "S -> epsilon", or "A -> a",
        where 'A', 'B', and 'C' are variables, 'S' is the axiom, and 'a' is a
        terminal. Optionally, two or more rules with the same left-hand side
        can be combined into one string using the form "A -> BC | a".

        A variable that appears on the right-hand side of a rule must also be
        defined on the left-hand side of at least one rule. The first variable
        to be defined is assumed to be the axiom of the CFG.

        If any rule is formatted incorrectly, raise a CFGFormatError.
        """
        self._rules: dict[str, set[str]] = {}

        for string in rules:
            self._add_rule(string)

        self._variables = self._rules.keys()
        self._axiom = next(iter(self._variables))

        self._validate_rules()

    def test_string(self, string: str) -> bool:
        """Using CYK, determine if a string can be generated by the CFG."""
        length = len(string)

        if length == 0:
            return self._EPSILON in self._rules[self._axiom]
        elif length == 1:
            return string in self._rules[self._axiom]

        table = [[set() for _ in range(length)] for _ in range(length)]

        # Generate bottom row using the characters of the input string
        for i in range(length):
            for variable in self._variables:
                if string[i] in self._rules[variable]:
                    table[i][i].add(variable)

        # Generate remaining rows using dynamic programming approach
        for row in range(1, length):
            for i in range(length - row):
                j = i + row

                for k in range(row):
                    result = _cross_product(table[i][i + k],
                                            table[i + k + 1][j])

                    # Find any variables that produce strings in the result
                    for string in result:
                        for variable in self._variables:
                            if string in self._rules[variable]:
                                table[i][j].add(variable)

        top_row = table[0][length - 1]
        return self._axiom in top_row

    def _add_rule(self, string: str) -> None:
        # Convert a string into a CFG rule and add it to the dict of rules.
        # If the string is not valid, raise a CFGFormatError.
        rule = re.sub(r"\s+", "", string)

        if not re.fullmatch(self._PATTERN, rule):
            raise CFGFormatError

        lhs = rule[0]
        rhs = rule[3:].split('|')

        if lhs not in self._rules:
            self._rules[lhs] = set(rhs)
        else:
            self._rules[lhs].union(set(rhs))

    def _validate_rules(self) -> None:
        # Raise a CFGFormatError if any variable appears on the right-hand
        # side of a rule but is never defined, or if epsilon appears on the
        # right-hand side of a variable that is not the axiom.
        for lhs, rhs in self._rules.items():
            for string in rhs:
                if len(string) == 2:
                    for variable in string:
                        if variable not in self._variables:
                            raise CFGFormatError
                elif string == self._EPSILON and lhs is not self._axiom:
                    raise CFGFormatError


class CFGFormatError(Exception):
    """Attempted to create a CFG from an invalid list of rules."""


def _cross_product(first_set: set[str], second_set: set[str]) -> set[str]:
    # Compute and return the cross product of two sets of strings.
    result = set()

    for string_first in first_set:
        for string_second in second_set:
            result.add(string_first + string_second)

    return result


def _parse_cmdline_args() -> argparse.Namespace:
    # Parse and return command-line arguments for the program.
    parser = argparse.ArgumentParser()
    parser.add_argument("-c", "--cfg", metavar="FILE",
                        help="the file to generate rules from")
    parser.add_argument("-t", "--test", metavar="FILE",
                        help="the file to test strings from")

    return parser.parse_args()


def _get_file_lines(filename: str) -> list[str]:
    # Read the lines of a file and return them as a list (newlines removed).
    # The program will print a message and exit if any problem is encountered.
    try:
        with open(filename) as file:
            return file.read().splitlines()
    except FileNotFoundError:
        print(f'File "{filename}" was not found.')
        sys.exit(1)
    except OSError:
        print(f'File "{filename}" could not be opened.')
        sys.exit(1)


def _test_user_input(cfg: CFG) -> None:
    # Prompt the user to enter a string, then test whether that string can
    # be generated by the CFG and display the result. The program will exit
    # gracefully on KeyboardInterrupt or EOFError encountered while waiting.
    try:
        string = input("Enter a string: ")
    except (KeyboardInterrupt, EOFError):
        sys.exit()

    _test_and_print(string, cfg)


def _test_and_print(string: str, cfg: CFG) -> None:
    # Test whether a string can be generated by a CFG and display the result.
    result = cfg.test_string(string)

    if result:
        print(f'String "{string}" can be generated by the CFG.')
    else:
        print(f'String "{string}" can NOT be generated by the CFG.')


if __name__ == "__main__":
    main()
