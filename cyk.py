import argparse
import re
import sys

CFG_DEFAULT_FILENAME = "cfg.txt"
CNF_PATTERN = re.compile("[A-Z]->([A-Z][A-Z]|[^A-Z])"
                         r"(\|([A-Z][A-Z]|[^A-Z]))*")


def main():
    """Performs CYK on strings input by the user until the program exits.

    The rules for the CFG that will be used by CYK are generated from a file.
    The name for this file can be provided using command-line arguments,
    otherwise CFG_DEFAULT_FILENAME will be used. The program will exit if the
    file is not found, or if the file does not contain a valid CFG.

    Once the rules have been generated, the user will be prompted to enter a
    string to be tested. CYK will be performed on this string, and the result
    will be displayed to the user. This functionality will repeat indefinitely
    until the program is terminated.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--file",
                        default=CFG_DEFAULT_FILENAME,
                        help='the file to generate rules from '
                             '(default: "%(default)s")')
    args = parser.parse_args()
    filename = args.file

    try:
        rules = generate_rules(filename)
    except FileNotFoundError:
        print(f'File "{filename}" was not found.')
        sys.exit(1)

    if rules is None:
        print(f'File "{filename}" does not contain a valid CFG.')
        sys.exit(1)

    while True:
        try:
            input_string = input("Enter a string: ")
        except (KeyboardInterrupt, EOFError):
            sys.exit()

        result = perform_cyk(input_string, rules)
        print(f'The string "{input_string}" {"can" if result else "can't"} '
              'be generated by the CFG.')


def generate_rules(filename: str) -> dict[str, list[str]] | None:
    """Reads the lines of a file and converts them into rules usable by CYK.

    If the file contains a valid CFG, a dictionary of rules corresponding to
    lines found in the file is returned. Otherwise, None is returned. To be
    considered valid, each line in the file must be of the form "A -> BC" or
    "A -> a", where 'A', 'B', and 'C' are non-terminal symbols, and 'a' is a
    terminal symbol. If the file is not found, a FileNotFoundError is raised.
    """
    rules: dict[str, list[str]] = {}

    with open(filename) as file:
        lines = file.readlines()

    for line in lines:
        rule = re.sub(r"\s+", "", line)

        if not re.fullmatch(CNF_PATTERN, rule):
            return None

        split_rule = rule.split("->")
        lhs = split_rule[0]
        rhs = split_rule[1].split('|')

        if lhs not in rules:
            rules[lhs] = rhs
        else:
            rules[lhs].extend(rhs)

    return rules


def perform_cyk(input_string: str, rules: dict[str, list[str]]) -> bool:
    """Determines if a string can be generated by the rules provided."""
    if not input_string:
        return False

    length = len(input_string)
    table = [[set() for _ in range(length)] for _ in range(length)]

    # Generate bottom row using the input string
    for i in range(length):
        for variable in rules:
            if input_string[i] in rules[variable]:
                table[i][i].add(variable)

    # Generate remaining rows using dynamic programming approach
    for row in range(1, length):
        for i in range(length - row):
            j = i + row

            for k in range(row):
                result = cross_product(table[i][i + k], table[i + k + 1][j])

                # Look for any variables that produce strings in the result
                for string in result:
                    for variable in rules:
                        if string in rules[variable]:
                            table[i][j].add(variable)

    start_variable = next(iter(rules))
    top_row = table[0][length - 1]
    return start_variable in top_row


def cross_product(first_set: set[str], second_set: set[str]) -> set[str]:
    """Computes and returns the cross product of two sets of strings."""
    result = set()

    for string_first in first_set:
        for string_second in second_set:
            result.add(string_first + string_second)

    return result


if __name__ == "__main__":
    main()
