import argparse
import re
import sys

CFG_DEFAULT_FILENAME = "cfg.txt"
CNF_PATTERN = re.compile(r"[A-Z]->([A-Z][A-Z]|[^A-Z])(\|([A-Z][A-Z]|[^A-Z]))*")

type CFGRules = dict[str, list[str]]


class CFGFormatError(Exception):
    """Raised when attempting to generate a rule from an invalid string."""


def main():
    """Performs CYK on strings input by the user until the program exits.

    The rules for the CFG that will be used by CYK are generated from a file.
    The name for this file can be provided using command-line arguments,
    otherwise CFG_DEFAULT_FILENAME will be used. The program will exit if the
    file is not found, or if the file does not contain a valid CFG.

    Once the rules have been generated, the user will be prompted to enter a
    string to be tested. CYK will be performed on this string, and the result
    will be displayed to the user. This functionality will repeat indefinitely
    until the program is terminated.
    """
    args = _get_cmdline_args()
    filename = args.file

    try:
        with open(filename) as file:
            lines = file.readlines()
    except FileNotFoundError:
        print(f'File "{filename}" was not found.')
        sys.exit(1)
    except OSError:
        print(f'File "{filename}" could not be opened.')
        sys.exit(1)

    try:
        rules = generate_rules(lines)
    except CFGFormatError:
        print(f'File "{filename}" does not contain a valid CFG.')
        sys.exit(1)

    try:
        while True:
            string = input("Enter a string: ")
            result = test_string(string, rules)

            if result:
                print(f'String "{string}" can be generated by the CFG.')
            else:
                print(f'String "{string}" can NOT be generated by the CFG.')
    except (KeyboardInterrupt, EOFError):
        sys.exit()


def generate_rules(lines: list[str]) -> CFGRules:
    """Reads the lines of a file and converts them into rules usable by CYK.

    A dictionary of rules generated from the lines provided is returned. Each
    line must be of the form "A -> BC" or "A -> a", where 'A', 'B', and 'C'
    are non-terminal symbols, and 'a' is a terminal symbol.

    Optionally, two or more rules with the same left-hand side can be combined
    onto one line using the form "A -> BC | a".

    If any line is formatted incorrectly, a CFGFormatError is raised.
    """
    rules: dict[str, list[str]] = {}
    for line in lines:
        rule = re.sub(r"\s+", "", line)

        if not re.fullmatch(CNF_PATTERN, rule):
            raise CFGFormatError

        split_rule = rule.split("->")
        lhs = split_rule[0]
        rhs = split_rule[1].split('|')

        if lhs not in rules:
            rules[lhs] = rhs
        else:
            rules[lhs].extend(rhs)

    return rules


def test_string(string: str, rules: CFGRules) -> bool:
    """Determines if a string can be generated by the rules provided."""
    if not string:
        return False

    length = len(string)
    table = [[set() for _ in range(length)] for _ in range(length)]

    # Generate bottom row using the input string
    for i in range(length):
        for variable in rules:
            if string[i] in rules[variable]:
                table[i][i].add(variable)

    # Generate remaining rows using dynamic programming approach
    for row in range(1, length):
        for i in range(length - row):
            j = i + row

            for k in range(row):
                result = _cross_product(table[i][i + k], table[i + k + 1][j])

                # Look for any variables that produce strings in the result
                for string in result:
                    for variable in rules:
                        if string in rules[variable]:
                            table[i][j].add(variable)

    start_variable = next(iter(rules))
    top_row = table[0][length - 1]
    return start_variable in top_row


def _cross_product(first_set: set[str], second_set: set[str]) -> set[str]:
    """Computes and returns the cross product of two sets of strings."""
    result = set()

    for string_first in first_set:
        for string_second in second_set:
            result.add(string_first + string_second)

    return result


def _get_cmdline_args() -> argparse.Namespace:
    """Parses and returns command-line arguments for the program."""
    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--file",
                        default=CFG_DEFAULT_FILENAME,
                        help='the file to generate rules from '
                             '(default: "%(default)s")')

    return parser.parse_args()


if __name__ == "__main__":
    main()
