import re

FILE_NAME = "cfg.txt"


def main():
    rules = generate_rules()

    if rules is None:
        print("The file does not contain a valid CFG in CNF.")
        return

    input_string = input("Enter a string: ")
    result = perform_cyk(input_string, rules)

    print(f'The string {"can" if result else "can't"} be generated by the CFG.')


# Returns a dictionary (string -> list of strings) matching lines found in the
# CFG file, or returns None if the file does not contain a valid CFG in CNF.
# To be valid, each line in the file must be of the form A -> BC or A -> a,
# where A, B, and C are non-terminal symbols, and a is a terminal symbol.
def generate_rules():
    rules = {}

    with open(FILE_NAME) as file:
        lines = file.read().splitlines()

    for line in lines:
        line = line.replace(' ', '')  # Ignore any spaces
        cnf_pattern = re.compile("[A-Z]->([A-Z][A-Z]|[^A-Z])")

        if not re.fullmatch(cnf_pattern, line):
            return None

        lhs = line[0]
        rhs = line[3:]  # Contains everything after the arrow

        if lhs in rules:
            rules[lhs].append(rhs)
        else:
            rules[lhs] = [rhs]

    return rules


# Uses the CYK algorithm to determine if the input string can be generated
# by the rules provided. Returns True if it can, and False otherwise.
def perform_cyk(input_string, rules):
    length = len(input_string)
    table = [[set() for _ in range(length)] for _ in range(length)]

    # Generate bottom row using the input string
    for i in range(length):
        for variable in rules:
            if input_string[i] in rules[variable]:
                table[i][i].add(variable)

    # Generate remaining rows using dynamic programming approach
    for row in range(1, length):
        for i in range(length - row):
            j = i + row

            for k in range(row):
                result = cross_product(table[i][i + k], table[i + k + 1][j])

                # Look for any variables that produce strings in the result
                for string in result:
                    for variable in rules:
                        if string in rules[variable]:
                            table[i][j].add(variable)

    # Determine if start variable (lhs of first rule) is in the top slot
    return next(iter(rules)) in table[0][length - 1]


# Returns a set containing the cross product of two sets of string variables.
def cross_product(first_set, second_set):
    result = set()

    for var_first in first_set:
        for var_second in second_set:
            result.add(var_first + var_second)

    return result


if __name__ == "__main__":
    main()
